// 프로그래머스 고득점 합격 Kit : 해시_베스트앨범
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

bool cmp(pair<int, int>x, pair<int, int>y) {
	if (x.first > y.first) { // first를 기준으로 오름차순 정렬
		return true;
	}
	else if (x.first == y.first) { // first값이 동일하다면
		if (x.second < y.second) { // second가 낮은순으로 정렬
			return true;
		}
	}
	return false;
}

vector<int> solution(vector<string> genres, vector<int> plays) {
	vector<int> answer;

	unordered_map<string, int> sumPlay_map; // 장르별 재생수의 합을 저장 (해시)
	unordered_map<string, vector<pair<int, int>>> songs; // 장르별 노래의 재생수와 고유번호를 저장
	for (int i = 0; i < genres.size(); i++) {
		sumPlay_map[genres[i]] += plays[i];
		songs[genres[i]].push_back({ plays[i],i });
	}

	vector<pair<int, string>> sumPlay_vec; // 장르별 재생수의 합을 저장 (벡터)
	// sumPlay_map를 sumPlay_vec로 옮긴다.
	for (auto tmp : sumPlay_map) {
		sumPlay_vec.push_back({ tmp.second, tmp.first });
	}
	sort(sumPlay_vec.begin(), sumPlay_vec.end()); // sumPlay_vec을 재생수를 기준으로 오름차순 정렬

	while (sumPlay_vec.size() > 0) {
		// sumPlay_vec에서 재생수가 가장 큰 {장르, 재생수} 한쌍을 꺼내온다.
		pair<int, string> bestGenre = sumPlay_vec.back();
		sumPlay_vec.pop_back();

		// 주어진 노래 중 장르가 bestGenre에 해당하는 모든 노래를 가져온다.
		vector<pair<int, int>> tmp = songs[bestGenre.second];
		sort(tmp.begin(), tmp.end(), cmp); // 가져온 노래 중 재생수가 높은 기준, 고유번호가 낮은 기준으로 정렬

		// 베스트앨범에 실을 곡 수를 정함
		int listedNum;
		listedNum = tmp.size() >= 2 ? 2 : 1; 

		// 베스트앨범에 곡을 실음
		for (int i = 0; i < listedNum; i++) {
			answer.push_back(tmp[i].second);
		}
	}

	return answer;
}