// 프로그래머스 고득점 합격 Kit : 그래프_가장 먼 노드
#include <string>
#include <vector> 
#include <queue>
#include <algorithm>
#include <iostream>

using namespace std;

bool cmp(int x, int y) {
	return x > y;
}

int solution(int n, vector<vector<int>> edge) {
	int answer = 0;

	// 주어진 간선 정보를 이용하여 노드를 연결함
	vector<vector<int>> graph(n + 1); // 그래프에 대한 정보를 저장
	for (auto tmp : edge) {
		graph[tmp[0]].push_back(tmp[1]);
		graph[tmp[1]].push_back(tmp[0]);
	}

	// bfs를 실행하여 노드1과 각 노드들 간의 거리를 구함
	bool *checked = new bool[n + 1]{false}; // 노드의 방문 여부를 저장
	int *distance = new int[n + 1]{0}; // 노드1과 각 노드들 사이의 거리를 저장

	// bfs실행
	queue<int> q;
	q.push(1);
	checked[1] = true;

	while (!q.empty()) {
		int x = q.front();
		q.pop();

		for (int i = 0; i < graph[x].size(); i++) {
			int y = graph[x][i];
			if (!checked[y]) {
				q.push(y);
				distance[y] = distance[x] + 1;
				checked[y] = true;
			}
		}
	}

	sort(distance, distance + (n + 1), cmp); // distance배열을 내림차순 정렬
	
	// 가장 멀리 떨어진 노드의 개수를 구함
	for (int i = 0; i < n + 1; i++) {
		if (distance[i] != distance[0]) break; // 가장 멀리 떨어진 노드가 아니라면
		answer++;
	}

	return answer;
}